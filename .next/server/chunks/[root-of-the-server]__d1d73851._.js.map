{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 6, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"","debugId":null}},
    {"offset": {"line": 84, "column": 0}, "map": {"version":3,"sources":["file:///home/bourbaki/ngoWorkNew/ngo2/src/app/api/media/route.ts"],"sourcesContent":["import { NextResponse } from 'next/server';\nimport fs from 'fs';\nimport path from 'path';\nimport { writeFile } from 'fs/promises';\n\nconst dataFilePath = path.join(process.cwd(), 'src/data/mediaEvents.json');\nconst uploadDir = path.join(process.cwd(), 'public/uploads');\n\n// Ensure upload directory exists\nif (!fs.existsSync(uploadDir)) {\n  fs.mkdirSync(uploadDir, { recursive: true });\n}\n\n// Helper function to read data\nconst readData = () => {\n  try {\n    const data = fs.readFileSync(dataFilePath, 'utf8');\n    return JSON.parse(data);\n  } catch (error) {\n    return { events: [] };\n  }\n};\n\n// Helper function to write data\nconst writeData = (data: any) => {\n  fs.writeFileSync(dataFilePath, JSON.stringify(data, null, 2));\n};\n\n// Helper function to save image\nasync function saveImage(file: File, eventId: string): Promise<string> {\n  const bytes = await file.arrayBuffer();\n  const buffer = Buffer.from(bytes);\n  \n  // Create directory if it doesn't exist\n  if (!fs.existsSync(uploadDir)) {\n    fs.mkdirSync(uploadDir, { recursive: true });\n  }\n  \n  // Get file extension\n  const extension = file.name.split('.').pop();\n  const fileName = `${eventId}.${extension}`;\n  const filePath = path.join(uploadDir, fileName);\n  \n  await writeFile(filePath, buffer);\n  return `/uploads/${fileName}`;\n}\n\n// GET all media events\nexport async function GET() {\n  try {\n    const data = readData();\n    return NextResponse.json(data.events);\n  } catch (error) {\n    return NextResponse.json({ error: 'Failed to fetch events' }, { status: 500 });\n  }\n}\n\n// POST new media event\nexport async function POST(request: Request) {\n  try {\n    const formData = await request.formData();\n    const eventId = Date.now().toString();\n    \n    // Handle image upload\n    const imageFile = formData.get('image') as File;\n    if (!imageFile) {\n      return NextResponse.json({ error: 'Image is required' }, { status: 400 });\n    }\n    \n    const imagePath = await saveImage(imageFile, eventId);\n    \n    // Create event object\n    const newEvent = {\n      id: eventId,\n      title: formData.get('title') as string,\n      date: formData.get('date') as string,\n      description: formData.get('description') as string,\n      location: formData.get('location') as string,\n      image: imagePath,\n      createdAt: new Date().toISOString(),\n      updatedAt: new Date().toISOString()\n    };\n    \n    // Save event\n    const data = readData();\n    data.events.push(newEvent);\n    writeData(data);\n    \n    return NextResponse.json(newEvent);\n  } catch (error) {\n    console.error('Error creating event:', error);\n    return NextResponse.json({ error: 'Failed to create event' }, { status: 500 });\n  }\n}\n\n// PUT update media event\nexport async function PUT(request: Request) {\n  try {\n    const formData = await request.formData();\n    const eventId = formData.get('id') as string;\n    \n    // Get existing event\n    const data = readData();\n    const existingEvent = data.events.find((e: any) => e.id === eventId);\n    if (!existingEvent) {\n      return NextResponse.json({ error: 'Event not found' }, { status: 404 });\n    }\n    \n    // Handle image upload if new image is provided\n    let imagePath = existingEvent.image;\n    const imageFile = formData.get('image') as File;\n    if (imageFile && imageFile.size > 0) {\n      // Delete old image if it exists\n      if (existingEvent.image) {\n        const oldImagePath = path.join(process.cwd(), 'public', existingEvent.image);\n        try {\n          fs.unlinkSync(oldImagePath);\n        } catch (error) {\n          console.error('Error deleting old image:', error);\n        }\n      }\n      imagePath = await saveImage(imageFile, eventId);\n    }\n    \n    // Update event object\n    const updatedEvent = {\n      ...existingEvent,\n      title: formData.get('title') as string,\n      date: formData.get('date') as string,\n      description: formData.get('description') as string,\n      location: formData.get('location') as string,\n      image: imagePath,\n      updatedAt: new Date().toISOString()\n    };\n    \n    // Save updated event\n    const index = data.events.findIndex((e: any) => e.id === eventId);\n    data.events[index] = updatedEvent;\n    writeData(data);\n    \n    return NextResponse.json(updatedEvent);\n  } catch (error) {\n    console.error('Error updating event:', error);\n    return NextResponse.json({ error: 'Failed to update event' }, { status: 500 });\n  }\n}\n\n// DELETE media event\nexport async function DELETE(request: Request) {\n  try {\n    const { searchParams } = new URL(request.url);\n    const id = searchParams.get('id');\n\n    if (!id) {\n      return NextResponse.json({ error: 'Event ID is required' }, { status: 400 });\n    }\n\n    const data = readData();\n    const eventIndex = data.events.findIndex((event: any) => event.id === id);\n\n    if (eventIndex === -1) {\n      return NextResponse.json({ error: 'Event not found' }, { status: 404 });\n    }\n\n    // Delete the associated image\n    const imagePath = path.join(process.cwd(), 'public', data.events[eventIndex].image);\n    if (fs.existsSync(imagePath)) {\n      fs.unlinkSync(imagePath);\n    }\n\n    data.events.splice(eventIndex, 1);\n    writeData(data);\n\n    return NextResponse.json({ message: 'Event deleted successfully' });\n  } catch (error) {\n    console.error('Error deleting event:', error);\n    return NextResponse.json({ error: 'Failed to delete event' }, { status: 500 });\n  }\n} "],"names":[],"mappings":"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","debugId":null}}]
}