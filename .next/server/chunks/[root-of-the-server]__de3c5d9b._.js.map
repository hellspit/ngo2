{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 6, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"","debugId":null}},
    {"offset": {"line": 84, "column": 0}, "map": {"version":3,"sources":["file:///home/bourbaki/ngoWorkNew/ngo2/src/app/api/events/route.ts"],"sourcesContent":["import { NextResponse } from 'next/server';\nimport { promises as fs } from 'fs';\nimport path from 'path';\nimport { writeFile } from 'fs/promises';\n\ninterface Event {\n  id: string;\n  title: string;\n  date: string;\n  description: string;\n  location: string;\n  image: string;\n  badge: string;\n}\n\nconst eventsFilePath = path.join(process.cwd(), 'data', 'events.json');\nconst eventsImageDir = path.join(process.cwd(), 'public', 'events');\n\n// Helper function to read events\nasync function readEvents(): Promise<Event[]> {\n  try {\n    const fileContents = await fs.readFile(eventsFilePath, 'utf8');\n    return JSON.parse(fileContents);\n  } catch (error) {\n    return [];\n  }\n}\n\n// Helper function to write events\nasync function writeEvents(events: Event[]) {\n  await fs.mkdir(path.dirname(eventsFilePath), { recursive: true });\n  await fs.writeFile(eventsFilePath, JSON.stringify(events, null, 2));\n}\n\n// Helper function to save image\nasync function saveImage(file: File, eventId: string): Promise<string> {\n  const bytes = await file.arrayBuffer();\n  const buffer = Buffer.from(bytes);\n  \n  // Create directory if it doesn't exist\n  await fs.mkdir(eventsImageDir, { recursive: true });\n  \n  // Get file extension\n  const extension = file.name.split('.').pop();\n  const fileName = `${eventId}.${extension}`;\n  const filePath = path.join(eventsImageDir, fileName);\n  \n  await writeFile(filePath, buffer);\n  return `/events/${fileName}`;\n}\n\n// GET /api/events\nexport async function GET() {\n  const events = await readEvents();\n  return NextResponse.json(events);\n}\n\n// POST /api/events\nexport async function POST(request: Request) {\n  try {\n    const formData = await request.formData();\n    const eventId = Date.now().toString();\n    \n    // Handle image upload\n    const imageFile = formData.get('image') as File;\n    if (!imageFile) {\n      return NextResponse.json({ error: 'Image is required' }, { status: 400 });\n    }\n    \n    const imagePath = await saveImage(imageFile, eventId);\n    \n    // Create event object\n    const event: Event = {\n      id: eventId,\n      title: formData.get('title') as string,\n      date: formData.get('date') as string,\n      description: formData.get('description') as string,\n      location: formData.get('location') as string,\n      image: imagePath,\n      badge: formData.get('badge') as string,\n    };\n    \n    // Save event\n    const events = await readEvents();\n    events.push(event);\n    await writeEvents(events);\n    \n    return NextResponse.json(event);\n  } catch (error) {\n    console.error('Error creating event:', error);\n    return NextResponse.json({ error: 'Failed to create event' }, { status: 500 });\n  }\n}\n\n// PUT /api/events\nexport async function PUT(request: Request) {\n  try {\n    const formData = await request.formData();\n    const eventId = formData.get('id') as string;\n    \n    // Get existing event\n    const events = await readEvents();\n    const existingEvent = events.find((e: Event) => e.id === eventId);\n    if (!existingEvent) {\n      return NextResponse.json({ error: 'Event not found' }, { status: 404 });\n    }\n    \n    // Handle image upload if new image is provided\n    let imagePath = existingEvent.image;\n    const imageFile = formData.get('image') as File;\n    if (imageFile && imageFile.size > 0) {\n      // Delete old image if it exists\n      if (existingEvent.image) {\n        const oldImagePath = path.join(process.cwd(), 'public', existingEvent.image);\n        try {\n          await fs.unlink(oldImagePath);\n        } catch (error) {\n          console.error('Error deleting old image:', error);\n        }\n      }\n      imagePath = await saveImage(imageFile, eventId);\n    }\n    \n    // Update event object\n    const updatedEvent: Event = {\n      id: eventId,\n      title: formData.get('title') as string,\n      date: formData.get('date') as string,\n      description: formData.get('description') as string,\n      location: formData.get('location') as string,\n      image: imagePath,\n      badge: formData.get('badge') as string,\n    };\n    \n    // Save updated event\n    const index = events.findIndex((e: Event) => e.id === eventId);\n    events[index] = updatedEvent;\n    await writeEvents(events);\n    \n    return NextResponse.json(updatedEvent);\n  } catch (error) {\n    console.error('Error updating event:', error);\n    return NextResponse.json({ error: 'Failed to update event' }, { status: 500 });\n  }\n}\n\n// DELETE /api/events\nexport async function DELETE(request: Request) {\n  try {\n    const { searchParams } = new URL(request.url);\n    const id = searchParams.get('id');\n\n    if (!id) {\n      return NextResponse.json({ error: 'Event ID is required' }, { status: 400 });\n    }\n\n    const events = await readEvents();\n    \n    // Find event to delete\n    const eventToDelete = events.find((e: Event) => e.id === id);\n    if (!eventToDelete) {\n      return NextResponse.json({ error: 'Event not found' }, { status: 404 });\n    }\n    \n    // Delete associated image\n    if (eventToDelete.image) {\n      const imagePath = path.join(process.cwd(), 'public', eventToDelete.image);\n      try {\n        await fs.unlink(imagePath);\n      } catch (error) {\n        console.error('Error deleting image:', error);\n      }\n    }\n    \n    // Delete event\n    const filteredEvents = events.filter((e: Event) => e.id !== id);\n    await writeEvents(filteredEvents);\n    \n    return NextResponse.json({ success: true });\n  } catch (error) {\n    console.error('Error deleting event:', error);\n    return NextResponse.json({ error: 'Failed to delete event' }, { status: 500 });\n  }\n}\n\n// host/api/v1/routes?= **\n// host/api/v2/routes?=events\n\n// host/endpoints?= **\n\n"],"names":[],"mappings":"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","debugId":null}}]
}